<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sebastian Hellmann’s website - The dynamic visibility, time, and evidence model (dynaViTE)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Sebastian Hellmann’s website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./dynaViTE_model.html" rel="" target="" aria-current="page">
 <span class="menu-text">The dynamic visibility, time, and evidence model (dynaViTE)</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#short-description-of-the-dynavite-model" id="toc-short-description-of-the-dynavite-model" class="nav-link active" data-scroll-target="#short-description-of-the-dynavite-model">Short description of the dynaViTE model</a></li>
  <li><a href="#simulation-of-the-dynavite-model" id="toc-simulation-of-the-dynavite-model" class="nav-link" data-scroll-target="#simulation-of-the-dynavite-model">Simulation of the dynaViTE model</a></li>
  <li><a href="#mathematical-details" id="toc-mathematical-details" class="nav-link" data-scroll-target="#mathematical-details">Mathematical details</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The dynamic visibility, time, and evidence model (dynaViTE)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="short-description-of-the-dynavite-model" class="level3">
<h3 class="anchored" data-anchor-id="short-description-of-the-dynavite-model">Short description of the dynaViTE model</h3>
<p>The dnyaViTE model is a mathematical model describing how confidence judgments are computed in dynamical evidence accumulation framework. It is based on the drift diffusion model. A noisy accumulation process (the decision process) accrues decision relevant information about the stimulus until a certain level of evidence is reached. At this time point the decision process hits an upper or a lower threshold, each representing one decision alternative. A decision is triggered for the choice corresponding to the reached threshold. DynaViTE generalizes the model by the assumption of a post-decisional accumulation (based on the two-stage dynamic signal detection theory of Pleskac &amp; Busemeyer, 2010). The decision proccess is not killed when it reaches a threshold, but continues to accumulate evidence for a fixed period of time (( ). In addition, there is a second accumulation taking place in the so-called visibility process. It accrues information of the difficulty of the decision, which is not related to the stimulus identity (like presentation time or any other context information which may be informative for how difficult the task is). An internal confidence variable is computed as follows. After the whole accumulation period (decision time + post-decisional accumulation time), the accumulated decision evidence from the decision process and the visibility information from the visibility process are combined in a weighted sum and divided by the total accumulation time to some power (a parameter ( ). To report confidence we assume that observers compare this confidence variable to a set of criteria to form a discrete confidence report.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="dynaViTE_model_files/figure-html/genmodel_DynaViTE-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Generative Model for dynaViTE</figcaption>
</figure>
</div>
</div>
</div>
<p>Vizualization of the dynaViTE model.</p>
<p>See below so simulate the behavior of the model and farer below for all mathematical details.</p>
</section>
<section id="simulation-of-the-dynavite-model" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="simulation-of-the-dynavite-model">Simulation of the dynaViTE model</h3>
<!--

-->
<div class="column-screen-inset">
<iframe height="700" width="100%" frameborder="no" src="https://sehellmann.shinyapps.io/shinyaccumulators/">
</iframe>
</div>
</section>
<section id="mathematical-details" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-details">Mathematical details</h3>
<section id="the-decision-process" class="level4">
<h4 class="anchored" data-anchor-id="the-decision-process">The decision process</h4>
<p>Mathematically, the decision process is a Wiener process <span class="math inline">\(X\)</span>, bounded from below and above by two time-constant thresholds, <span class="math inline">\(0\)</span> and <span class="math inline">\(a&gt;0\)</span>. The decision process starts at a starting point <span class="math inline">\(X(0)=az\)</span> and evolves with a constant drift <span class="math inline">\(\mu\)</span> and a diffusion constant <span class="math inline">\(s\)</span> (which is often set to 1 as a scaling factor when fitting the model to empirical data). In accordance with the drift diffusion model (Ratcliff &amp; McKoon, 2008), the model includes between-trial variability of starting point and drift rate. The relative starting point <span class="math inline">\(z\)</span> varies uniformly with range <span class="math inline">\(sz\)</span> and the drift rate is normally distributed between trials with standard deviation <span class="math inline">\(s_\nu\)</span> and mean <span class="math inline">\(\nu\)</span>. As soon as the process crosses one of the boundaries, a decision is triggered, i.e.&nbsp;the decision time is <span class="math inline">\(T_D = \min\{t |X(t)\notin [0,a]\}\)</span> . The response <span class="math inline">\(R\)</span> is 1, if <span class="math inline">\(X(T_D )\geq a\)</span>, and it is -1, if <span class="math inline">\(X(T_D )\leq 0\)</span>. Up to this point the model is identical to the drift diffusion model of decision-making. #### Post-decisional accumulation First, the model assumes that the decision process is not killed at decision time but continues to accumulate evidence for some period <span class="math inline">\(\tau\)</span>. This feature is called post-decisional accumulation (Pleskac &amp; Busemeyer, 2010). #### Parallel accumulation of visibility Second, dynaViTE includes a second process evolving in parallel to the decision process. We refer to the second process as the visibility process. The visibility process is assumed to accrue information about task irrelevant stimulus features which are informative about task difficulty but not for stimulus identity. Formally, the visibility process is a second Wiener process <span class="math inline">\(Vis\)</span>, which starts at 0 and evolves with constant drift rate and diffusion constant. The diffusion constant of the visibility process is an extra parameter <span class="math inline">\(s_{Vis}\)</span>. The drift rate of the visibility process is also assumed to vary between trials according to a normal distribution with standard deviation <span class="math inline">\(\sigma_{Vis}\)</span> and mean drift rate <span class="math inline">\(\mu_{Vis}\)</span>. #### Computation of the confidence variable The internal confidence variable is computed as a weighted sum of accrued evidence in the decision process and the visibility process during the decision and post-decisional accumulation time, divided by a power of the accumulation time. Formally, the internal confidence variable is represented by <span class="math display">\[c_{dynWEV}=\frac{wR(X(T_D+\tau )-az)+(1-w)Vis(T_D+\tau )}{(T_D +\tau )^\lambda},\]</span> where <span class="math inline">\(w\in [0,1]\)</span> is the weight on decision evidence. The multiplication of the accumulated decision evidence with the decision response <span class="math inline">\(R\)</span> leads to higher confidence when the accumulated evidence supports the decision. Because <span class="math inline">\(R=-1\)</span> represents a “lower” decision, a smaller value of <span class="math inline">\(X(T_D+\tau )\)</span> and thus a smaller value for <span class="math inline">\(X(T_D+\tau )-az\)</span> would support the decision and thus increase confidence. The parameter <span class="math inline">\(\lambda \geq 0\)</span> represent the penatly of accumulation time on confidence. The term in the denominator leads to a decrease of confidence for longer decision accumulation times, even if the final amount of evidence would be the same. The reasoning behind this is that longer responses are usually related to lower confidence (Rahnev et al., 2020).</p>
<p>The confidence variable is compared to a set of criteria <span class="math inline">\(\vartheta_{R,i},i=1,...k-1\)</span> to form a discrete confidence judgment with <span class="math inline">\(k\)</span> steps. Precisely, if the choice is <span class="math inline">\(R\)</span> then the reported confidence is <span class="math inline">\(K\)</span>, if <span class="math inline">\(c_{dynaViTE} \in [\vartheta_{R,K-1},\vartheta_{R,K}]\)</span>, with <span class="math inline">\(\vartheta_{R,0} = -\infty\)</span> and <span class="math inline">\(\vartheta_{R,k}=\infty\)</span>.</p>
</section>
<section id="connection-to-other-models" class="level4">
<h4 class="anchored" data-anchor-id="connection-to-other-models">Connection to other models</h4>
<p>This model includes some other dynamic models of confidence published in the literature before as special cases (Hellmann et al., 2023). Most importanty, the dynaViTE model is based on the dynWEV model which does not include the explicit accumulation time penalty in the confidence variable (i.e.&nbsp;<span class="math inline">\(\lambda=0\)</span>). In addition, as the two-stage dynamic signal detection theory (2DSD; Pleskac &amp; Busemeyer, 2010) is a special case of dynWEV for <span class="math inline">\(w=1\)</span>, is is also a special case for dynaViTE when <span class="math inline">\(\lambda=0\)</span> and <span class="math inline">\(w=1\)</span>. Finally, we denote the special case of dynaViTE with only <span class="math inline">\(w=1\)</span> as 2DSDT. In this case, the visibility process does not influence confidence at all, such that only the decision process determines choice as well as confidence via post-decisional accumulation. The confidence variable in 2DSDT is then solely based on accumulated evidence about stimulus identity over accumulation time, such that 2DSDT represents the analogous generalization of 2DSD with explicit influence of accumulation time in confidence.</p>
</section>
<section id="usage-of-the-model-with-empirical-data" class="level4">
<h4 class="anchored" data-anchor-id="usage-of-the-model-with-empirical-data">Usage of the model with empirical data</h4>
<p>The model can be applied to binary choice tasks. The direction of the decision drift rate usually depends on the true stimulus identity <span class="math inline">\(S\in \{-1, 1\}\)</span>. Moreover, in many experimental tasks, the difficulty of the decision is manipulated which is often assumed to change the magnitude <span class="math inline">\(d&gt;0\)</span> of the mean drift rate. Therefore, the mean decision drift rate could be computed by <span class="math inline">\(\nu=Sd\)</span>.</p>
<p>The visibility process is stochastically inpedendent of the decision process. However, in an experimental situation where task difficulty is manipulated, it may be plausible to assume that changes in difficulty may be percieved independently of the decision relevant information about stimulus identity. Therefore, the mean drift of the visibility process also depends on <span class="math inline">\(d\)</span>. So far, we used to set <span class="math inline">\(\mu_{Vis}=d\)</span> directly in our applications (Hellmann et al., 2023). Thus, the visibility process is independent of the decision process, despite both being influenced by task difficulty <span class="math inline">\(d\)</span>. This also means, the visibility process has always a non-negative mean drift rate.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>